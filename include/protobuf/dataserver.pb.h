// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dataserver.proto

#ifndef PROTOBUF_dataserver_2eproto__INCLUDED
#define PROTOBUF_dataserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dataserver {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dataserver_2eproto();
void protobuf_AssignDesc_dataserver_2eproto();
void protobuf_ShutdownFile_dataserver_2eproto();

class UserStockCfg;
class SetUsrStkCfg;
class SetSingleUsrStkCfg;
class SingleUserStkCfg;
class IncrUsrStkCfg;
class GetUsrStkCfg;
class GetIncrStkCfg;
class UidDevices;
class UidDevices_appinfos;
class SetUidDevices;
class GetUidDevices;
class UsrStockRes;
class UidDeviceRes;

enum ResponseCode {
  OK = 0,
  NOT_FIND = -1,
  TIME_OUT = -2,
  SERVER_INTERNAL = -3,
  EXIST_TASK = -4,
  UNKNOWN = -1000
};
bool ResponseCode_IsValid(int value);
const ResponseCode ResponseCode_MIN = UNKNOWN;
const ResponseCode ResponseCode_MAX = OK;
const int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseCode_descriptor();
inline const ::std::string& ResponseCode_Name(ResponseCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseCode_descriptor(), value);
}
inline bool ResponseCode_Parse(
    const ::std::string& name, ResponseCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
enum flagtype {
  VALID = 1,
  INVALID = -1
};
bool flagtype_IsValid(int value);
const flagtype flagtype_MIN = INVALID;
const flagtype flagtype_MAX = VALID;
const int flagtype_ARRAYSIZE = flagtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* flagtype_descriptor();
inline const ::std::string& flagtype_Name(flagtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    flagtype_descriptor(), value);
}
inline bool flagtype_Parse(
    const ::std::string& name, flagtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flagtype>(
    flagtype_descriptor(), name, value);
}
// ===================================================================

class UserStockCfg : public ::google::protobuf::Message {
 public:
  UserStockCfg();
  virtual ~UserStockCfg();

  UserStockCfg(const UserStockCfg& from);

  inline UserStockCfg& operator=(const UserStockCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStockCfg& default_instance();

  void Swap(UserStockCfg* other);

  // implements Message ----------------------------------------------

  UserStockCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserStockCfg& from);
  void MergeFrom(const UserStockCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string stockcode = 1;
  inline bool has_stockcode() const;
  inline void clear_stockcode();
  static const int kStockcodeFieldNumber = 1;
  inline const ::std::string& stockcode() const;
  inline void set_stockcode(const ::std::string& value);
  inline void set_stockcode(const char* value);
  inline void set_stockcode(const char* value, size_t size);
  inline ::std::string* mutable_stockcode();
  inline ::std::string* release_stockcode();
  inline void set_allocated_stockcode(::std::string* stockcode);

  // required int64 bulletin = 2 [default = 1];
  inline bool has_bulletin() const;
  inline void clear_bulletin();
  static const int kBulletinFieldNumber = 2;
  inline ::google::protobuf::int64 bulletin() const;
  inline void set_bulletin(::google::protobuf::int64 value);

  // optional float max_price = 3;
  inline bool has_max_price() const;
  inline void clear_max_price();
  static const int kMaxPriceFieldNumber = 3;
  inline float max_price() const;
  inline void set_max_price(float value);

  // optional float min_price = 4;
  inline bool has_min_price() const;
  inline void clear_min_price();
  static const int kMinPriceFieldNumber = 4;
  inline float min_price() const;
  inline void set_min_price(float value);

  // optional float range = 5;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 5;
  inline float range() const;
  inline void set_range(float value);

  // required int64 run = 6 [default = 1];
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 6;
  inline ::google::protobuf::int64 run() const;
  inline void set_run(::google::protobuf::int64 value);

  // required int64 incrementid = 7;
  inline bool has_incrementid() const;
  inline void clear_incrementid();
  static const int kIncrementidFieldNumber = 7;
  inline ::google::protobuf::int64 incrementid() const;
  inline void set_incrementid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:dataserver.UserStockCfg)
 private:
  inline void set_has_stockcode();
  inline void clear_has_stockcode();
  inline void set_has_bulletin();
  inline void clear_has_bulletin();
  inline void set_has_max_price();
  inline void clear_has_max_price();
  inline void set_has_min_price();
  inline void clear_has_min_price();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_run();
  inline void clear_has_run();
  inline void set_has_incrementid();
  inline void clear_has_incrementid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stockcode_;
  ::google::protobuf::int64 bulletin_;
  float max_price_;
  float min_price_;
  ::google::protobuf::int64 run_;
  ::google::protobuf::int64 incrementid_;
  float range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static UserStockCfg* default_instance_;
};
// -------------------------------------------------------------------

class SetUsrStkCfg : public ::google::protobuf::Message {
 public:
  SetUsrStkCfg();
  virtual ~SetUsrStkCfg();

  SetUsrStkCfg(const SetUsrStkCfg& from);

  inline SetUsrStkCfg& operator=(const SetUsrStkCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetUsrStkCfg& default_instance();

  void Swap(SetUsrStkCfg* other);

  // implements Message ----------------------------------------------

  SetUsrStkCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetUsrStkCfg& from);
  void MergeFrom(const SetUsrStkCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required string usrid = 2;
  inline bool has_usrid() const;
  inline void clear_usrid();
  static const int kUsridFieldNumber = 2;
  inline const ::std::string& usrid() const;
  inline void set_usrid(const ::std::string& value);
  inline void set_usrid(const char* value);
  inline void set_usrid(const char* value, size_t size);
  inline ::std::string* mutable_usrid();
  inline ::std::string* release_usrid();
  inline void set_allocated_usrid(::std::string* usrid);

  // repeated .dataserver.UserStockCfg stkcfg = 3;
  inline int stkcfg_size() const;
  inline void clear_stkcfg();
  static const int kStkcfgFieldNumber = 3;
  inline const ::dataserver::UserStockCfg& stkcfg(int index) const;
  inline ::dataserver::UserStockCfg* mutable_stkcfg(int index);
  inline ::dataserver::UserStockCfg* add_stkcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >&
      stkcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >*
      mutable_stkcfg();

  // @@protoc_insertion_point(class_scope:dataserver.SetUsrStkCfg)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_usrid();
  inline void clear_has_usrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* usrid_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg > stkcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static SetUsrStkCfg* default_instance_;
};
// -------------------------------------------------------------------

class SetSingleUsrStkCfg : public ::google::protobuf::Message {
 public:
  SetSingleUsrStkCfg();
  virtual ~SetSingleUsrStkCfg();

  SetSingleUsrStkCfg(const SetSingleUsrStkCfg& from);

  inline SetSingleUsrStkCfg& operator=(const SetSingleUsrStkCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetSingleUsrStkCfg& default_instance();

  void Swap(SetSingleUsrStkCfg* other);

  // implements Message ----------------------------------------------

  SetSingleUsrStkCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetSingleUsrStkCfg& from);
  void MergeFrom(const SetSingleUsrStkCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required string usrid = 2;
  inline bool has_usrid() const;
  inline void clear_usrid();
  static const int kUsridFieldNumber = 2;
  inline const ::std::string& usrid() const;
  inline void set_usrid(const ::std::string& value);
  inline void set_usrid(const char* value);
  inline void set_usrid(const char* value, size_t size);
  inline ::std::string* mutable_usrid();
  inline ::std::string* release_usrid();
  inline void set_allocated_usrid(::std::string* usrid);

  // required string stockcode = 3;
  inline bool has_stockcode() const;
  inline void clear_stockcode();
  static const int kStockcodeFieldNumber = 3;
  inline const ::std::string& stockcode() const;
  inline void set_stockcode(const ::std::string& value);
  inline void set_stockcode(const char* value);
  inline void set_stockcode(const char* value, size_t size);
  inline ::std::string* mutable_stockcode();
  inline ::std::string* release_stockcode();
  inline void set_allocated_stockcode(::std::string* stockcode);

  // required int64 bulletin = 4 [default = 1];
  inline bool has_bulletin() const;
  inline void clear_bulletin();
  static const int kBulletinFieldNumber = 4;
  inline ::google::protobuf::int64 bulletin() const;
  inline void set_bulletin(::google::protobuf::int64 value);

  // optional float max_price = 5;
  inline bool has_max_price() const;
  inline void clear_max_price();
  static const int kMaxPriceFieldNumber = 5;
  inline float max_price() const;
  inline void set_max_price(float value);

  // optional float min_price = 6;
  inline bool has_min_price() const;
  inline void clear_min_price();
  static const int kMinPriceFieldNumber = 6;
  inline float min_price() const;
  inline void set_min_price(float value);

  // optional float range = 7;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 7;
  inline float range() const;
  inline void set_range(float value);

  // required int64 run = 8 [default = 1];
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 8;
  inline ::google::protobuf::int64 run() const;
  inline void set_run(::google::protobuf::int64 value);

  // required int64 incrementid = 9;
  inline bool has_incrementid() const;
  inline void clear_incrementid();
  static const int kIncrementidFieldNumber = 9;
  inline ::google::protobuf::int64 incrementid() const;
  inline void set_incrementid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:dataserver.SetSingleUsrStkCfg)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_usrid();
  inline void clear_has_usrid();
  inline void set_has_stockcode();
  inline void clear_has_stockcode();
  inline void set_has_bulletin();
  inline void clear_has_bulletin();
  inline void set_has_max_price();
  inline void clear_has_max_price();
  inline void set_has_min_price();
  inline void clear_has_min_price();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_run();
  inline void clear_has_run();
  inline void set_has_incrementid();
  inline void clear_has_incrementid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* usrid_;
  ::std::string* stockcode_;
  ::google::protobuf::int64 bulletin_;
  float max_price_;
  float min_price_;
  ::google::protobuf::int64 run_;
  ::google::protobuf::int64 incrementid_;
  float range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static SetSingleUsrStkCfg* default_instance_;
};
// -------------------------------------------------------------------

class SingleUserStkCfg : public ::google::protobuf::Message {
 public:
  SingleUserStkCfg();
  virtual ~SingleUserStkCfg();

  SingleUserStkCfg(const SingleUserStkCfg& from);

  inline SingleUserStkCfg& operator=(const SingleUserStkCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleUserStkCfg& default_instance();

  void Swap(SingleUserStkCfg* other);

  // implements Message ----------------------------------------------

  SingleUserStkCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleUserStkCfg& from);
  void MergeFrom(const SingleUserStkCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string usrid = 1;
  inline bool has_usrid() const;
  inline void clear_usrid();
  static const int kUsridFieldNumber = 1;
  inline const ::std::string& usrid() const;
  inline void set_usrid(const ::std::string& value);
  inline void set_usrid(const char* value);
  inline void set_usrid(const char* value, size_t size);
  inline ::std::string* mutable_usrid();
  inline ::std::string* release_usrid();
  inline void set_allocated_usrid(::std::string* usrid);

  // repeated .dataserver.UserStockCfg stkcfg = 2;
  inline int stkcfg_size() const;
  inline void clear_stkcfg();
  static const int kStkcfgFieldNumber = 2;
  inline const ::dataserver::UserStockCfg& stkcfg(int index) const;
  inline ::dataserver::UserStockCfg* mutable_stkcfg(int index);
  inline ::dataserver::UserStockCfg* add_stkcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >&
      stkcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >*
      mutable_stkcfg();

  // @@protoc_insertion_point(class_scope:dataserver.SingleUserStkCfg)
 private:
  inline void set_has_usrid();
  inline void clear_has_usrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* usrid_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg > stkcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static SingleUserStkCfg* default_instance_;
};
// -------------------------------------------------------------------

class IncrUsrStkCfg : public ::google::protobuf::Message {
 public:
  IncrUsrStkCfg();
  virtual ~IncrUsrStkCfg();

  IncrUsrStkCfg(const IncrUsrStkCfg& from);

  inline IncrUsrStkCfg& operator=(const IncrUsrStkCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrUsrStkCfg& default_instance();

  void Swap(IncrUsrStkCfg* other);

  // implements Message ----------------------------------------------

  IncrUsrStkCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncrUsrStkCfg& from);
  void MergeFrom(const IncrUsrStkCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // repeated .dataserver.SingleUserStkCfg items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::dataserver::SingleUserStkCfg& items(int index) const;
  inline ::dataserver::SingleUserStkCfg* mutable_items(int index);
  inline ::dataserver::SingleUserStkCfg* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::SingleUserStkCfg >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::SingleUserStkCfg >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:dataserver.IncrUsrStkCfg)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::SingleUserStkCfg > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static IncrUsrStkCfg* default_instance_;
};
// -------------------------------------------------------------------

class GetUsrStkCfg : public ::google::protobuf::Message {
 public:
  GetUsrStkCfg();
  virtual ~GetUsrStkCfg();

  GetUsrStkCfg(const GetUsrStkCfg& from);

  inline GetUsrStkCfg& operator=(const GetUsrStkCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUsrStkCfg& default_instance();

  void Swap(GetUsrStkCfg* other);

  // implements Message ----------------------------------------------

  GetUsrStkCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUsrStkCfg& from);
  void MergeFrom(const GetUsrStkCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required string usrid = 2;
  inline bool has_usrid() const;
  inline void clear_usrid();
  static const int kUsridFieldNumber = 2;
  inline const ::std::string& usrid() const;
  inline void set_usrid(const ::std::string& value);
  inline void set_usrid(const char* value);
  inline void set_usrid(const char* value, size_t size);
  inline ::std::string* mutable_usrid();
  inline ::std::string* release_usrid();
  inline void set_allocated_usrid(::std::string* usrid);

  // optional int64 incrementid = 3;
  inline bool has_incrementid() const;
  inline void clear_incrementid();
  static const int kIncrementidFieldNumber = 3;
  inline ::google::protobuf::int64 incrementid() const;
  inline void set_incrementid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:dataserver.GetUsrStkCfg)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_usrid();
  inline void clear_has_usrid();
  inline void set_has_incrementid();
  inline void clear_has_incrementid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* usrid_;
  ::google::protobuf::int64 incrementid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static GetUsrStkCfg* default_instance_;
};
// -------------------------------------------------------------------

class GetIncrStkCfg : public ::google::protobuf::Message {
 public:
  GetIncrStkCfg();
  virtual ~GetIncrStkCfg();

  GetIncrStkCfg(const GetIncrStkCfg& from);

  inline GetIncrStkCfg& operator=(const GetIncrStkCfg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIncrStkCfg& default_instance();

  void Swap(GetIncrStkCfg* other);

  // implements Message ----------------------------------------------

  GetIncrStkCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetIncrStkCfg& from);
  void MergeFrom(const GetIncrStkCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 incrementid = 1;
  inline bool has_incrementid() const;
  inline void clear_incrementid();
  static const int kIncrementidFieldNumber = 1;
  inline ::google::protobuf::int64 incrementid() const;
  inline void set_incrementid(::google::protobuf::int64 value);

  // required int64 count = 2 [default = 10];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int64 count() const;
  inline void set_count(::google::protobuf::int64 value);

  // required string taskid = 3;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 3;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // @@protoc_insertion_point(class_scope:dataserver.GetIncrStkCfg)
 private:
  inline void set_has_incrementid();
  inline void clear_has_incrementid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_taskid();
  inline void clear_has_taskid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 incrementid_;
  ::google::protobuf::int64 count_;
  ::std::string* taskid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static GetIncrStkCfg* default_instance_;
};
// -------------------------------------------------------------------

class UidDevices_appinfos : public ::google::protobuf::Message {
 public:
  UidDevices_appinfos();
  virtual ~UidDevices_appinfos();

  UidDevices_appinfos(const UidDevices_appinfos& from);

  inline UidDevices_appinfos& operator=(const UidDevices_appinfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UidDevices_appinfos& default_instance();

  void Swap(UidDevices_appinfos* other);

  // implements Message ----------------------------------------------

  UidDevices_appinfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UidDevices_appinfos& from);
  void MergeFrom(const UidDevices_appinfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string apptype = 1;
  inline bool has_apptype() const;
  inline void clear_apptype();
  static const int kApptypeFieldNumber = 1;
  inline const ::std::string& apptype() const;
  inline void set_apptype(const ::std::string& value);
  inline void set_apptype(const char* value);
  inline void set_apptype(const char* value, size_t size);
  inline ::std::string* mutable_apptype();
  inline ::std::string* release_apptype();
  inline void set_allocated_apptype(::std::string* apptype);

  // required .dataserver.flagtype flag = 2 [default = VALID];
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::dataserver::flagtype flag() const;
  inline void set_flag(::dataserver::flagtype value);

  // required string lastuid = 3;
  inline bool has_lastuid() const;
  inline void clear_lastuid();
  static const int kLastuidFieldNumber = 3;
  inline const ::std::string& lastuid() const;
  inline void set_lastuid(const ::std::string& value);
  inline void set_lastuid(const char* value);
  inline void set_lastuid(const char* value, size_t size);
  inline ::std::string* mutable_lastuid();
  inline ::std::string* release_lastuid();
  inline void set_allocated_lastuid(::std::string* lastuid);

  // required int64 lasttime = 4;
  inline bool has_lasttime() const;
  inline void clear_lasttime();
  static const int kLasttimeFieldNumber = 4;
  inline ::google::protobuf::int64 lasttime() const;
  inline void set_lasttime(::google::protobuf::int64 value);

  // required string appversion = 5;
  inline bool has_appversion() const;
  inline void clear_appversion();
  static const int kAppversionFieldNumber = 5;
  inline const ::std::string& appversion() const;
  inline void set_appversion(const ::std::string& value);
  inline void set_appversion(const char* value);
  inline void set_appversion(const char* value, size_t size);
  inline ::std::string* mutable_appversion();
  inline ::std::string* release_appversion();
  inline void set_allocated_appversion(::std::string* appversion);

  // @@protoc_insertion_point(class_scope:dataserver.UidDevices.appinfos)
 private:
  inline void set_has_apptype();
  inline void clear_has_apptype();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_lastuid();
  inline void clear_has_lastuid();
  inline void set_has_lasttime();
  inline void clear_has_lasttime();
  inline void set_has_appversion();
  inline void clear_has_appversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* apptype_;
  ::std::string* lastuid_;
  ::google::protobuf::int64 lasttime_;
  ::std::string* appversion_;
  int flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static UidDevices_appinfos* default_instance_;
};
// -------------------------------------------------------------------

class UidDevices : public ::google::protobuf::Message {
 public:
  UidDevices();
  virtual ~UidDevices();

  UidDevices(const UidDevices& from);

  inline UidDevices& operator=(const UidDevices& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UidDevices& default_instance();

  void Swap(UidDevices* other);

  // implements Message ----------------------------------------------

  UidDevices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UidDevices& from);
  void MergeFrom(const UidDevices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UidDevices_appinfos appinfos;

  // accessors -------------------------------------------------------

  // required string osversion = 1;
  inline bool has_osversion() const;
  inline void clear_osversion();
  static const int kOsversionFieldNumber = 1;
  inline const ::std::string& osversion() const;
  inline void set_osversion(const ::std::string& value);
  inline void set_osversion(const char* value);
  inline void set_osversion(const char* value, size_t size);
  inline ::std::string* mutable_osversion();
  inline ::std::string* release_osversion();
  inline void set_allocated_osversion(::std::string* osversion);

  // optional string comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .dataserver.UidDevices.appinfos apps = 3;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 3;
  inline const ::dataserver::UidDevices_appinfos& apps(int index) const;
  inline ::dataserver::UidDevices_appinfos* mutable_apps(int index);
  inline ::dataserver::UidDevices_appinfos* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices_appinfos >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices_appinfos >*
      mutable_apps();

  // @@protoc_insertion_point(class_scope:dataserver.UidDevices)
 private:
  inline void set_has_osversion();
  inline void clear_has_osversion();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* osversion_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices_appinfos > apps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static UidDevices* default_instance_;
};
// -------------------------------------------------------------------

class SetUidDevices : public ::google::protobuf::Message {
 public:
  SetUidDevices();
  virtual ~SetUidDevices();

  SetUidDevices(const SetUidDevices& from);

  inline SetUidDevices& operator=(const SetUidDevices& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetUidDevices& default_instance();

  void Swap(SetUidDevices* other);

  // implements Message ----------------------------------------------

  SetUidDevices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetUidDevices& from);
  void MergeFrom(const SetUidDevices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required string device = 2;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 2;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // repeated .dataserver.UidDevices data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::dataserver::UidDevices& data(int index) const;
  inline ::dataserver::UidDevices* mutable_data(int index);
  inline ::dataserver::UidDevices* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:dataserver.SetUidDevices)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* device_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static SetUidDevices* default_instance_;
};
// -------------------------------------------------------------------

class GetUidDevices : public ::google::protobuf::Message {
 public:
  GetUidDevices();
  virtual ~GetUidDevices();

  GetUidDevices(const GetUidDevices& from);

  inline GetUidDevices& operator=(const GetUidDevices& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUidDevices& default_instance();

  void Swap(GetUidDevices* other);

  // implements Message ----------------------------------------------

  GetUidDevices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUidDevices& from);
  void MergeFrom(const GetUidDevices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required string device = 2;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 2;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional int64 incrementid = 3;
  inline bool has_incrementid() const;
  inline void clear_incrementid();
  static const int kIncrementidFieldNumber = 3;
  inline ::google::protobuf::int64 incrementid() const;
  inline void set_incrementid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:dataserver.GetUidDevices)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_incrementid();
  inline void clear_has_incrementid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* device_;
  ::google::protobuf::int64 incrementid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static GetUidDevices* default_instance_;
};
// -------------------------------------------------------------------

class UsrStockRes : public ::google::protobuf::Message {
 public:
  UsrStockRes();
  virtual ~UsrStockRes();

  UsrStockRes(const UsrStockRes& from);

  inline UsrStockRes& operator=(const UsrStockRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UsrStockRes& default_instance();

  void Swap(UsrStockRes* other);

  // implements Message ----------------------------------------------

  UsrStockRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UsrStockRes& from);
  void MergeFrom(const UsrStockRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .dataserver.ResponseCode response_code = 2;
  inline bool has_response_code() const;
  inline void clear_response_code();
  static const int kResponseCodeFieldNumber = 2;
  inline ::dataserver::ResponseCode response_code() const;
  inline void set_response_code(::dataserver::ResponseCode value);

  // optional string usrid = 3;
  inline bool has_usrid() const;
  inline void clear_usrid();
  static const int kUsridFieldNumber = 3;
  inline const ::std::string& usrid() const;
  inline void set_usrid(const ::std::string& value);
  inline void set_usrid(const char* value);
  inline void set_usrid(const char* value, size_t size);
  inline ::std::string* mutable_usrid();
  inline ::std::string* release_usrid();
  inline void set_allocated_usrid(::std::string* usrid);

  // repeated .dataserver.UserStockCfg data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::dataserver::UserStockCfg& data(int index) const;
  inline ::dataserver::UserStockCfg* mutable_data(int index);
  inline ::dataserver::UserStockCfg* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:dataserver.UsrStockRes)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_response_code();
  inline void clear_has_response_code();
  inline void set_has_usrid();
  inline void clear_has_usrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* usrid_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg > data_;
  int response_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static UsrStockRes* default_instance_;
};
// -------------------------------------------------------------------

class UidDeviceRes : public ::google::protobuf::Message {
 public:
  UidDeviceRes();
  virtual ~UidDeviceRes();

  UidDeviceRes(const UidDeviceRes& from);

  inline UidDeviceRes& operator=(const UidDeviceRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UidDeviceRes& default_instance();

  void Swap(UidDeviceRes* other);

  // implements Message ----------------------------------------------

  UidDeviceRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UidDeviceRes& from);
  void MergeFrom(const UidDeviceRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline const ::std::string& taskid() const;
  inline void set_taskid(const ::std::string& value);
  inline void set_taskid(const char* value);
  inline void set_taskid(const char* value, size_t size);
  inline ::std::string* mutable_taskid();
  inline ::std::string* release_taskid();
  inline void set_allocated_taskid(::std::string* taskid);

  // required .dataserver.ResponseCode reponse_code = 2;
  inline bool has_reponse_code() const;
  inline void clear_reponse_code();
  static const int kReponseCodeFieldNumber = 2;
  inline ::dataserver::ResponseCode reponse_code() const;
  inline void set_reponse_code(::dataserver::ResponseCode value);

  // optional string device = 3;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 3;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // repeated .dataserver.UidDevices data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::dataserver::UidDevices& data(int index) const;
  inline ::dataserver::UidDevices* mutable_data(int index);
  inline ::dataserver::UidDevices* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:dataserver.UidDeviceRes)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_reponse_code();
  inline void clear_has_reponse_code();
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* taskid_;
  ::std::string* device_;
  ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices > data_;
  int reponse_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_dataserver_2eproto();
  friend void protobuf_AssignDesc_dataserver_2eproto();
  friend void protobuf_ShutdownFile_dataserver_2eproto();

  void InitAsDefaultInstance();
  static UidDeviceRes* default_instance_;
};
// ===================================================================


// ===================================================================

// UserStockCfg

// required string stockcode = 1;
inline bool UserStockCfg::has_stockcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStockCfg::set_has_stockcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStockCfg::clear_has_stockcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStockCfg::clear_stockcode() {
  if (stockcode_ != &::google::protobuf::internal::kEmptyString) {
    stockcode_->clear();
  }
  clear_has_stockcode();
}
inline const ::std::string& UserStockCfg::stockcode() const {
  return *stockcode_;
}
inline void UserStockCfg::set_stockcode(const ::std::string& value) {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  stockcode_->assign(value);
}
inline void UserStockCfg::set_stockcode(const char* value) {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  stockcode_->assign(value);
}
inline void UserStockCfg::set_stockcode(const char* value, size_t size) {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  stockcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStockCfg::mutable_stockcode() {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  return stockcode_;
}
inline ::std::string* UserStockCfg::release_stockcode() {
  clear_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockcode_;
    stockcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserStockCfg::set_allocated_stockcode(::std::string* stockcode) {
  if (stockcode_ != &::google::protobuf::internal::kEmptyString) {
    delete stockcode_;
  }
  if (stockcode) {
    set_has_stockcode();
    stockcode_ = stockcode;
  } else {
    clear_has_stockcode();
    stockcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 bulletin = 2 [default = 1];
inline bool UserStockCfg::has_bulletin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStockCfg::set_has_bulletin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStockCfg::clear_has_bulletin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStockCfg::clear_bulletin() {
  bulletin_ = GOOGLE_LONGLONG(1);
  clear_has_bulletin();
}
inline ::google::protobuf::int64 UserStockCfg::bulletin() const {
  return bulletin_;
}
inline void UserStockCfg::set_bulletin(::google::protobuf::int64 value) {
  set_has_bulletin();
  bulletin_ = value;
}

// optional float max_price = 3;
inline bool UserStockCfg::has_max_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStockCfg::set_has_max_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStockCfg::clear_has_max_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStockCfg::clear_max_price() {
  max_price_ = 0;
  clear_has_max_price();
}
inline float UserStockCfg::max_price() const {
  return max_price_;
}
inline void UserStockCfg::set_max_price(float value) {
  set_has_max_price();
  max_price_ = value;
}

// optional float min_price = 4;
inline bool UserStockCfg::has_min_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStockCfg::set_has_min_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStockCfg::clear_has_min_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStockCfg::clear_min_price() {
  min_price_ = 0;
  clear_has_min_price();
}
inline float UserStockCfg::min_price() const {
  return min_price_;
}
inline void UserStockCfg::set_min_price(float value) {
  set_has_min_price();
  min_price_ = value;
}

// optional float range = 5;
inline bool UserStockCfg::has_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStockCfg::set_has_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStockCfg::clear_has_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStockCfg::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float UserStockCfg::range() const {
  return range_;
}
inline void UserStockCfg::set_range(float value) {
  set_has_range();
  range_ = value;
}

// required int64 run = 6 [default = 1];
inline bool UserStockCfg::has_run() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStockCfg::set_has_run() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStockCfg::clear_has_run() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStockCfg::clear_run() {
  run_ = GOOGLE_LONGLONG(1);
  clear_has_run();
}
inline ::google::protobuf::int64 UserStockCfg::run() const {
  return run_;
}
inline void UserStockCfg::set_run(::google::protobuf::int64 value) {
  set_has_run();
  run_ = value;
}

// required int64 incrementid = 7;
inline bool UserStockCfg::has_incrementid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStockCfg::set_has_incrementid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStockCfg::clear_has_incrementid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStockCfg::clear_incrementid() {
  incrementid_ = GOOGLE_LONGLONG(0);
  clear_has_incrementid();
}
inline ::google::protobuf::int64 UserStockCfg::incrementid() const {
  return incrementid_;
}
inline void UserStockCfg::set_incrementid(::google::protobuf::int64 value) {
  set_has_incrementid();
  incrementid_ = value;
}

// -------------------------------------------------------------------

// SetUsrStkCfg

// required string taskid = 1;
inline bool SetUsrStkCfg::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetUsrStkCfg::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetUsrStkCfg::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetUsrStkCfg::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SetUsrStkCfg::taskid() const {
  return *taskid_;
}
inline void SetUsrStkCfg::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SetUsrStkCfg::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SetUsrStkCfg::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetUsrStkCfg::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SetUsrStkCfg::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetUsrStkCfg::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string usrid = 2;
inline bool SetUsrStkCfg::has_usrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetUsrStkCfg::set_has_usrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetUsrStkCfg::clear_has_usrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetUsrStkCfg::clear_usrid() {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    usrid_->clear();
  }
  clear_has_usrid();
}
inline const ::std::string& SetUsrStkCfg::usrid() const {
  return *usrid_;
}
inline void SetUsrStkCfg::set_usrid(const ::std::string& value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void SetUsrStkCfg::set_usrid(const char* value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void SetUsrStkCfg::set_usrid(const char* value, size_t size) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetUsrStkCfg::mutable_usrid() {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  return usrid_;
}
inline ::std::string* SetUsrStkCfg::release_usrid() {
  clear_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usrid_;
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetUsrStkCfg::set_allocated_usrid(::std::string* usrid) {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    delete usrid_;
  }
  if (usrid) {
    set_has_usrid();
    usrid_ = usrid;
  } else {
    clear_has_usrid();
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.UserStockCfg stkcfg = 3;
inline int SetUsrStkCfg::stkcfg_size() const {
  return stkcfg_.size();
}
inline void SetUsrStkCfg::clear_stkcfg() {
  stkcfg_.Clear();
}
inline const ::dataserver::UserStockCfg& SetUsrStkCfg::stkcfg(int index) const {
  return stkcfg_.Get(index);
}
inline ::dataserver::UserStockCfg* SetUsrStkCfg::mutable_stkcfg(int index) {
  return stkcfg_.Mutable(index);
}
inline ::dataserver::UserStockCfg* SetUsrStkCfg::add_stkcfg() {
  return stkcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >&
SetUsrStkCfg::stkcfg() const {
  return stkcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >*
SetUsrStkCfg::mutable_stkcfg() {
  return &stkcfg_;
}

// -------------------------------------------------------------------

// SetSingleUsrStkCfg

// required string taskid = 1;
inline bool SetSingleUsrStkCfg::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetSingleUsrStkCfg::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetSingleUsrStkCfg::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SetSingleUsrStkCfg::taskid() const {
  return *taskid_;
}
inline void SetSingleUsrStkCfg::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SetSingleUsrStkCfg::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SetSingleUsrStkCfg::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetSingleUsrStkCfg::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SetSingleUsrStkCfg::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetSingleUsrStkCfg::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string usrid = 2;
inline bool SetSingleUsrStkCfg::has_usrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_usrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetSingleUsrStkCfg::clear_has_usrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetSingleUsrStkCfg::clear_usrid() {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    usrid_->clear();
  }
  clear_has_usrid();
}
inline const ::std::string& SetSingleUsrStkCfg::usrid() const {
  return *usrid_;
}
inline void SetSingleUsrStkCfg::set_usrid(const ::std::string& value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void SetSingleUsrStkCfg::set_usrid(const char* value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void SetSingleUsrStkCfg::set_usrid(const char* value, size_t size) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetSingleUsrStkCfg::mutable_usrid() {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  return usrid_;
}
inline ::std::string* SetSingleUsrStkCfg::release_usrid() {
  clear_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usrid_;
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetSingleUsrStkCfg::set_allocated_usrid(::std::string* usrid) {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    delete usrid_;
  }
  if (usrid) {
    set_has_usrid();
    usrid_ = usrid;
  } else {
    clear_has_usrid();
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string stockcode = 3;
inline bool SetSingleUsrStkCfg::has_stockcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_stockcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetSingleUsrStkCfg::clear_has_stockcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetSingleUsrStkCfg::clear_stockcode() {
  if (stockcode_ != &::google::protobuf::internal::kEmptyString) {
    stockcode_->clear();
  }
  clear_has_stockcode();
}
inline const ::std::string& SetSingleUsrStkCfg::stockcode() const {
  return *stockcode_;
}
inline void SetSingleUsrStkCfg::set_stockcode(const ::std::string& value) {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  stockcode_->assign(value);
}
inline void SetSingleUsrStkCfg::set_stockcode(const char* value) {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  stockcode_->assign(value);
}
inline void SetSingleUsrStkCfg::set_stockcode(const char* value, size_t size) {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  stockcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetSingleUsrStkCfg::mutable_stockcode() {
  set_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    stockcode_ = new ::std::string;
  }
  return stockcode_;
}
inline ::std::string* SetSingleUsrStkCfg::release_stockcode() {
  clear_has_stockcode();
  if (stockcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockcode_;
    stockcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetSingleUsrStkCfg::set_allocated_stockcode(::std::string* stockcode) {
  if (stockcode_ != &::google::protobuf::internal::kEmptyString) {
    delete stockcode_;
  }
  if (stockcode) {
    set_has_stockcode();
    stockcode_ = stockcode;
  } else {
    clear_has_stockcode();
    stockcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 bulletin = 4 [default = 1];
inline bool SetSingleUsrStkCfg::has_bulletin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_bulletin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetSingleUsrStkCfg::clear_has_bulletin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetSingleUsrStkCfg::clear_bulletin() {
  bulletin_ = GOOGLE_LONGLONG(1);
  clear_has_bulletin();
}
inline ::google::protobuf::int64 SetSingleUsrStkCfg::bulletin() const {
  return bulletin_;
}
inline void SetSingleUsrStkCfg::set_bulletin(::google::protobuf::int64 value) {
  set_has_bulletin();
  bulletin_ = value;
}

// optional float max_price = 5;
inline bool SetSingleUsrStkCfg::has_max_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_max_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetSingleUsrStkCfg::clear_has_max_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetSingleUsrStkCfg::clear_max_price() {
  max_price_ = 0;
  clear_has_max_price();
}
inline float SetSingleUsrStkCfg::max_price() const {
  return max_price_;
}
inline void SetSingleUsrStkCfg::set_max_price(float value) {
  set_has_max_price();
  max_price_ = value;
}

// optional float min_price = 6;
inline bool SetSingleUsrStkCfg::has_min_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_min_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetSingleUsrStkCfg::clear_has_min_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetSingleUsrStkCfg::clear_min_price() {
  min_price_ = 0;
  clear_has_min_price();
}
inline float SetSingleUsrStkCfg::min_price() const {
  return min_price_;
}
inline void SetSingleUsrStkCfg::set_min_price(float value) {
  set_has_min_price();
  min_price_ = value;
}

// optional float range = 7;
inline bool SetSingleUsrStkCfg::has_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SetSingleUsrStkCfg::clear_has_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SetSingleUsrStkCfg::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float SetSingleUsrStkCfg::range() const {
  return range_;
}
inline void SetSingleUsrStkCfg::set_range(float value) {
  set_has_range();
  range_ = value;
}

// required int64 run = 8 [default = 1];
inline bool SetSingleUsrStkCfg::has_run() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_run() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SetSingleUsrStkCfg::clear_has_run() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SetSingleUsrStkCfg::clear_run() {
  run_ = GOOGLE_LONGLONG(1);
  clear_has_run();
}
inline ::google::protobuf::int64 SetSingleUsrStkCfg::run() const {
  return run_;
}
inline void SetSingleUsrStkCfg::set_run(::google::protobuf::int64 value) {
  set_has_run();
  run_ = value;
}

// required int64 incrementid = 9;
inline bool SetSingleUsrStkCfg::has_incrementid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SetSingleUsrStkCfg::set_has_incrementid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SetSingleUsrStkCfg::clear_has_incrementid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SetSingleUsrStkCfg::clear_incrementid() {
  incrementid_ = GOOGLE_LONGLONG(0);
  clear_has_incrementid();
}
inline ::google::protobuf::int64 SetSingleUsrStkCfg::incrementid() const {
  return incrementid_;
}
inline void SetSingleUsrStkCfg::set_incrementid(::google::protobuf::int64 value) {
  set_has_incrementid();
  incrementid_ = value;
}

// -------------------------------------------------------------------

// SingleUserStkCfg

// required string usrid = 1;
inline bool SingleUserStkCfg::has_usrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleUserStkCfg::set_has_usrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleUserStkCfg::clear_has_usrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleUserStkCfg::clear_usrid() {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    usrid_->clear();
  }
  clear_has_usrid();
}
inline const ::std::string& SingleUserStkCfg::usrid() const {
  return *usrid_;
}
inline void SingleUserStkCfg::set_usrid(const ::std::string& value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void SingleUserStkCfg::set_usrid(const char* value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void SingleUserStkCfg::set_usrid(const char* value, size_t size) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleUserStkCfg::mutable_usrid() {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  return usrid_;
}
inline ::std::string* SingleUserStkCfg::release_usrid() {
  clear_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usrid_;
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleUserStkCfg::set_allocated_usrid(::std::string* usrid) {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    delete usrid_;
  }
  if (usrid) {
    set_has_usrid();
    usrid_ = usrid;
  } else {
    clear_has_usrid();
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.UserStockCfg stkcfg = 2;
inline int SingleUserStkCfg::stkcfg_size() const {
  return stkcfg_.size();
}
inline void SingleUserStkCfg::clear_stkcfg() {
  stkcfg_.Clear();
}
inline const ::dataserver::UserStockCfg& SingleUserStkCfg::stkcfg(int index) const {
  return stkcfg_.Get(index);
}
inline ::dataserver::UserStockCfg* SingleUserStkCfg::mutable_stkcfg(int index) {
  return stkcfg_.Mutable(index);
}
inline ::dataserver::UserStockCfg* SingleUserStkCfg::add_stkcfg() {
  return stkcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >&
SingleUserStkCfg::stkcfg() const {
  return stkcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >*
SingleUserStkCfg::mutable_stkcfg() {
  return &stkcfg_;
}

// -------------------------------------------------------------------

// IncrUsrStkCfg

// required string taskid = 1;
inline bool IncrUsrStkCfg::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncrUsrStkCfg::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncrUsrStkCfg::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncrUsrStkCfg::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& IncrUsrStkCfg::taskid() const {
  return *taskid_;
}
inline void IncrUsrStkCfg::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void IncrUsrStkCfg::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void IncrUsrStkCfg::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IncrUsrStkCfg::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* IncrUsrStkCfg::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IncrUsrStkCfg::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.SingleUserStkCfg items = 2;
inline int IncrUsrStkCfg::items_size() const {
  return items_.size();
}
inline void IncrUsrStkCfg::clear_items() {
  items_.Clear();
}
inline const ::dataserver::SingleUserStkCfg& IncrUsrStkCfg::items(int index) const {
  return items_.Get(index);
}
inline ::dataserver::SingleUserStkCfg* IncrUsrStkCfg::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::dataserver::SingleUserStkCfg* IncrUsrStkCfg::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::SingleUserStkCfg >&
IncrUsrStkCfg::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::SingleUserStkCfg >*
IncrUsrStkCfg::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// GetUsrStkCfg

// required string taskid = 1;
inline bool GetUsrStkCfg::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUsrStkCfg::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUsrStkCfg::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUsrStkCfg::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& GetUsrStkCfg::taskid() const {
  return *taskid_;
}
inline void GetUsrStkCfg::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void GetUsrStkCfg::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void GetUsrStkCfg::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUsrStkCfg::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* GetUsrStkCfg::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUsrStkCfg::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string usrid = 2;
inline bool GetUsrStkCfg::has_usrid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUsrStkCfg::set_has_usrid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUsrStkCfg::clear_has_usrid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUsrStkCfg::clear_usrid() {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    usrid_->clear();
  }
  clear_has_usrid();
}
inline const ::std::string& GetUsrStkCfg::usrid() const {
  return *usrid_;
}
inline void GetUsrStkCfg::set_usrid(const ::std::string& value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void GetUsrStkCfg::set_usrid(const char* value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void GetUsrStkCfg::set_usrid(const char* value, size_t size) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUsrStkCfg::mutable_usrid() {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  return usrid_;
}
inline ::std::string* GetUsrStkCfg::release_usrid() {
  clear_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usrid_;
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUsrStkCfg::set_allocated_usrid(::std::string* usrid) {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    delete usrid_;
  }
  if (usrid) {
    set_has_usrid();
    usrid_ = usrid;
  } else {
    clear_has_usrid();
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 incrementid = 3;
inline bool GetUsrStkCfg::has_incrementid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUsrStkCfg::set_has_incrementid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUsrStkCfg::clear_has_incrementid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUsrStkCfg::clear_incrementid() {
  incrementid_ = GOOGLE_LONGLONG(0);
  clear_has_incrementid();
}
inline ::google::protobuf::int64 GetUsrStkCfg::incrementid() const {
  return incrementid_;
}
inline void GetUsrStkCfg::set_incrementid(::google::protobuf::int64 value) {
  set_has_incrementid();
  incrementid_ = value;
}

// -------------------------------------------------------------------

// GetIncrStkCfg

// required int64 incrementid = 1;
inline bool GetIncrStkCfg::has_incrementid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIncrStkCfg::set_has_incrementid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIncrStkCfg::clear_has_incrementid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIncrStkCfg::clear_incrementid() {
  incrementid_ = GOOGLE_LONGLONG(0);
  clear_has_incrementid();
}
inline ::google::protobuf::int64 GetIncrStkCfg::incrementid() const {
  return incrementid_;
}
inline void GetIncrStkCfg::set_incrementid(::google::protobuf::int64 value) {
  set_has_incrementid();
  incrementid_ = value;
}

// required int64 count = 2 [default = 10];
inline bool GetIncrStkCfg::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetIncrStkCfg::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetIncrStkCfg::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetIncrStkCfg::clear_count() {
  count_ = GOOGLE_LONGLONG(10);
  clear_has_count();
}
inline ::google::protobuf::int64 GetIncrStkCfg::count() const {
  return count_;
}
inline void GetIncrStkCfg::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
}

// required string taskid = 3;
inline bool GetIncrStkCfg::has_taskid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetIncrStkCfg::set_has_taskid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetIncrStkCfg::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetIncrStkCfg::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& GetIncrStkCfg::taskid() const {
  return *taskid_;
}
inline void GetIncrStkCfg::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void GetIncrStkCfg::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void GetIncrStkCfg::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIncrStkCfg::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* GetIncrStkCfg::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetIncrStkCfg::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UidDevices_appinfos

// required string apptype = 1;
inline bool UidDevices_appinfos::has_apptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UidDevices_appinfos::set_has_apptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UidDevices_appinfos::clear_has_apptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UidDevices_appinfos::clear_apptype() {
  if (apptype_ != &::google::protobuf::internal::kEmptyString) {
    apptype_->clear();
  }
  clear_has_apptype();
}
inline const ::std::string& UidDevices_appinfos::apptype() const {
  return *apptype_;
}
inline void UidDevices_appinfos::set_apptype(const ::std::string& value) {
  set_has_apptype();
  if (apptype_ == &::google::protobuf::internal::kEmptyString) {
    apptype_ = new ::std::string;
  }
  apptype_->assign(value);
}
inline void UidDevices_appinfos::set_apptype(const char* value) {
  set_has_apptype();
  if (apptype_ == &::google::protobuf::internal::kEmptyString) {
    apptype_ = new ::std::string;
  }
  apptype_->assign(value);
}
inline void UidDevices_appinfos::set_apptype(const char* value, size_t size) {
  set_has_apptype();
  if (apptype_ == &::google::protobuf::internal::kEmptyString) {
    apptype_ = new ::std::string;
  }
  apptype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDevices_appinfos::mutable_apptype() {
  set_has_apptype();
  if (apptype_ == &::google::protobuf::internal::kEmptyString) {
    apptype_ = new ::std::string;
  }
  return apptype_;
}
inline ::std::string* UidDevices_appinfos::release_apptype() {
  clear_has_apptype();
  if (apptype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apptype_;
    apptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDevices_appinfos::set_allocated_apptype(::std::string* apptype) {
  if (apptype_ != &::google::protobuf::internal::kEmptyString) {
    delete apptype_;
  }
  if (apptype) {
    set_has_apptype();
    apptype_ = apptype;
  } else {
    clear_has_apptype();
    apptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .dataserver.flagtype flag = 2 [default = VALID];
inline bool UidDevices_appinfos::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UidDevices_appinfos::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UidDevices_appinfos::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UidDevices_appinfos::clear_flag() {
  flag_ = 1;
  clear_has_flag();
}
inline ::dataserver::flagtype UidDevices_appinfos::flag() const {
  return static_cast< ::dataserver::flagtype >(flag_);
}
inline void UidDevices_appinfos::set_flag(::dataserver::flagtype value) {
  assert(::dataserver::flagtype_IsValid(value));
  set_has_flag();
  flag_ = value;
}

// required string lastuid = 3;
inline bool UidDevices_appinfos::has_lastuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UidDevices_appinfos::set_has_lastuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UidDevices_appinfos::clear_has_lastuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UidDevices_appinfos::clear_lastuid() {
  if (lastuid_ != &::google::protobuf::internal::kEmptyString) {
    lastuid_->clear();
  }
  clear_has_lastuid();
}
inline const ::std::string& UidDevices_appinfos::lastuid() const {
  return *lastuid_;
}
inline void UidDevices_appinfos::set_lastuid(const ::std::string& value) {
  set_has_lastuid();
  if (lastuid_ == &::google::protobuf::internal::kEmptyString) {
    lastuid_ = new ::std::string;
  }
  lastuid_->assign(value);
}
inline void UidDevices_appinfos::set_lastuid(const char* value) {
  set_has_lastuid();
  if (lastuid_ == &::google::protobuf::internal::kEmptyString) {
    lastuid_ = new ::std::string;
  }
  lastuid_->assign(value);
}
inline void UidDevices_appinfos::set_lastuid(const char* value, size_t size) {
  set_has_lastuid();
  if (lastuid_ == &::google::protobuf::internal::kEmptyString) {
    lastuid_ = new ::std::string;
  }
  lastuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDevices_appinfos::mutable_lastuid() {
  set_has_lastuid();
  if (lastuid_ == &::google::protobuf::internal::kEmptyString) {
    lastuid_ = new ::std::string;
  }
  return lastuid_;
}
inline ::std::string* UidDevices_appinfos::release_lastuid() {
  clear_has_lastuid();
  if (lastuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastuid_;
    lastuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDevices_appinfos::set_allocated_lastuid(::std::string* lastuid) {
  if (lastuid_ != &::google::protobuf::internal::kEmptyString) {
    delete lastuid_;
  }
  if (lastuid) {
    set_has_lastuid();
    lastuid_ = lastuid;
  } else {
    clear_has_lastuid();
    lastuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 lasttime = 4;
inline bool UidDevices_appinfos::has_lasttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UidDevices_appinfos::set_has_lasttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UidDevices_appinfos::clear_has_lasttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UidDevices_appinfos::clear_lasttime() {
  lasttime_ = GOOGLE_LONGLONG(0);
  clear_has_lasttime();
}
inline ::google::protobuf::int64 UidDevices_appinfos::lasttime() const {
  return lasttime_;
}
inline void UidDevices_appinfos::set_lasttime(::google::protobuf::int64 value) {
  set_has_lasttime();
  lasttime_ = value;
}

// required string appversion = 5;
inline bool UidDevices_appinfos::has_appversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UidDevices_appinfos::set_has_appversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UidDevices_appinfos::clear_has_appversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UidDevices_appinfos::clear_appversion() {
  if (appversion_ != &::google::protobuf::internal::kEmptyString) {
    appversion_->clear();
  }
  clear_has_appversion();
}
inline const ::std::string& UidDevices_appinfos::appversion() const {
  return *appversion_;
}
inline void UidDevices_appinfos::set_appversion(const ::std::string& value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
}
inline void UidDevices_appinfos::set_appversion(const char* value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
}
inline void UidDevices_appinfos::set_appversion(const char* value, size_t size) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDevices_appinfos::mutable_appversion() {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  return appversion_;
}
inline ::std::string* UidDevices_appinfos::release_appversion() {
  clear_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appversion_;
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDevices_appinfos::set_allocated_appversion(::std::string* appversion) {
  if (appversion_ != &::google::protobuf::internal::kEmptyString) {
    delete appversion_;
  }
  if (appversion) {
    set_has_appversion();
    appversion_ = appversion;
  } else {
    clear_has_appversion();
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UidDevices

// required string osversion = 1;
inline bool UidDevices::has_osversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UidDevices::set_has_osversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UidDevices::clear_has_osversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UidDevices::clear_osversion() {
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    osversion_->clear();
  }
  clear_has_osversion();
}
inline const ::std::string& UidDevices::osversion() const {
  return *osversion_;
}
inline void UidDevices::set_osversion(const ::std::string& value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void UidDevices::set_osversion(const char* value) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void UidDevices::set_osversion(const char* value, size_t size) {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDevices::mutable_osversion() {
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  return osversion_;
}
inline ::std::string* UidDevices::release_osversion() {
  clear_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osversion_;
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDevices::set_allocated_osversion(::std::string* osversion) {
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    delete osversion_;
  }
  if (osversion) {
    set_has_osversion();
    osversion_ = osversion;
  } else {
    clear_has_osversion();
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string comment = 2;
inline bool UidDevices::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UidDevices::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UidDevices::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UidDevices::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& UidDevices::comment() const {
  return *comment_;
}
inline void UidDevices::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void UidDevices::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void UidDevices::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDevices::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* UidDevices::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDevices::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.UidDevices.appinfos apps = 3;
inline int UidDevices::apps_size() const {
  return apps_.size();
}
inline void UidDevices::clear_apps() {
  apps_.Clear();
}
inline const ::dataserver::UidDevices_appinfos& UidDevices::apps(int index) const {
  return apps_.Get(index);
}
inline ::dataserver::UidDevices_appinfos* UidDevices::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::dataserver::UidDevices_appinfos* UidDevices::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices_appinfos >&
UidDevices::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices_appinfos >*
UidDevices::mutable_apps() {
  return &apps_;
}

// -------------------------------------------------------------------

// SetUidDevices

// required string taskid = 1;
inline bool SetUidDevices::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetUidDevices::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetUidDevices::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetUidDevices::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& SetUidDevices::taskid() const {
  return *taskid_;
}
inline void SetUidDevices::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SetUidDevices::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void SetUidDevices::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetUidDevices::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* SetUidDevices::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetUidDevices::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string device = 2;
inline bool SetUidDevices::has_device() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetUidDevices::set_has_device() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetUidDevices::clear_has_device() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetUidDevices::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& SetUidDevices::device() const {
  return *device_;
}
inline void SetUidDevices::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void SetUidDevices::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void SetUidDevices::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetUidDevices::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* SetUidDevices::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetUidDevices::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.UidDevices data = 3;
inline int SetUidDevices::data_size() const {
  return data_.size();
}
inline void SetUidDevices::clear_data() {
  data_.Clear();
}
inline const ::dataserver::UidDevices& SetUidDevices::data(int index) const {
  return data_.Get(index);
}
inline ::dataserver::UidDevices* SetUidDevices::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::dataserver::UidDevices* SetUidDevices::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >&
SetUidDevices::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >*
SetUidDevices::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// GetUidDevices

// required string taskid = 1;
inline bool GetUidDevices::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUidDevices::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUidDevices::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUidDevices::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& GetUidDevices::taskid() const {
  return *taskid_;
}
inline void GetUidDevices::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void GetUidDevices::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void GetUidDevices::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUidDevices::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* GetUidDevices::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUidDevices::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string device = 2;
inline bool GetUidDevices::has_device() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUidDevices::set_has_device() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUidDevices::clear_has_device() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUidDevices::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& GetUidDevices::device() const {
  return *device_;
}
inline void GetUidDevices::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void GetUidDevices::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void GetUidDevices::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUidDevices::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* GetUidDevices::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUidDevices::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 incrementid = 3;
inline bool GetUidDevices::has_incrementid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUidDevices::set_has_incrementid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUidDevices::clear_has_incrementid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUidDevices::clear_incrementid() {
  incrementid_ = GOOGLE_LONGLONG(0);
  clear_has_incrementid();
}
inline ::google::protobuf::int64 GetUidDevices::incrementid() const {
  return incrementid_;
}
inline void GetUidDevices::set_incrementid(::google::protobuf::int64 value) {
  set_has_incrementid();
  incrementid_ = value;
}

// -------------------------------------------------------------------

// UsrStockRes

// required string taskid = 1;
inline bool UsrStockRes::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsrStockRes::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UsrStockRes::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UsrStockRes::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& UsrStockRes::taskid() const {
  return *taskid_;
}
inline void UsrStockRes::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void UsrStockRes::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void UsrStockRes::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsrStockRes::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* UsrStockRes::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsrStockRes::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .dataserver.ResponseCode response_code = 2;
inline bool UsrStockRes::has_response_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsrStockRes::set_has_response_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UsrStockRes::clear_has_response_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UsrStockRes::clear_response_code() {
  response_code_ = 0;
  clear_has_response_code();
}
inline ::dataserver::ResponseCode UsrStockRes::response_code() const {
  return static_cast< ::dataserver::ResponseCode >(response_code_);
}
inline void UsrStockRes::set_response_code(::dataserver::ResponseCode value) {
  assert(::dataserver::ResponseCode_IsValid(value));
  set_has_response_code();
  response_code_ = value;
}

// optional string usrid = 3;
inline bool UsrStockRes::has_usrid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UsrStockRes::set_has_usrid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UsrStockRes::clear_has_usrid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UsrStockRes::clear_usrid() {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    usrid_->clear();
  }
  clear_has_usrid();
}
inline const ::std::string& UsrStockRes::usrid() const {
  return *usrid_;
}
inline void UsrStockRes::set_usrid(const ::std::string& value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void UsrStockRes::set_usrid(const char* value) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(value);
}
inline void UsrStockRes::set_usrid(const char* value, size_t size) {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  usrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsrStockRes::mutable_usrid() {
  set_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    usrid_ = new ::std::string;
  }
  return usrid_;
}
inline ::std::string* UsrStockRes::release_usrid() {
  clear_has_usrid();
  if (usrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usrid_;
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UsrStockRes::set_allocated_usrid(::std::string* usrid) {
  if (usrid_ != &::google::protobuf::internal::kEmptyString) {
    delete usrid_;
  }
  if (usrid) {
    set_has_usrid();
    usrid_ = usrid;
  } else {
    clear_has_usrid();
    usrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.UserStockCfg data = 4;
inline int UsrStockRes::data_size() const {
  return data_.size();
}
inline void UsrStockRes::clear_data() {
  data_.Clear();
}
inline const ::dataserver::UserStockCfg& UsrStockRes::data(int index) const {
  return data_.Get(index);
}
inline ::dataserver::UserStockCfg* UsrStockRes::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::dataserver::UserStockCfg* UsrStockRes::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >&
UsrStockRes::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::UserStockCfg >*
UsrStockRes::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// UidDeviceRes

// required string taskid = 1;
inline bool UidDeviceRes::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UidDeviceRes::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UidDeviceRes::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UidDeviceRes::clear_taskid() {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    taskid_->clear();
  }
  clear_has_taskid();
}
inline const ::std::string& UidDeviceRes::taskid() const {
  return *taskid_;
}
inline void UidDeviceRes::set_taskid(const ::std::string& value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void UidDeviceRes::set_taskid(const char* value) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(value);
}
inline void UidDeviceRes::set_taskid(const char* value, size_t size) {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  taskid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDeviceRes::mutable_taskid() {
  set_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    taskid_ = new ::std::string;
  }
  return taskid_;
}
inline ::std::string* UidDeviceRes::release_taskid() {
  clear_has_taskid();
  if (taskid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskid_;
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDeviceRes::set_allocated_taskid(::std::string* taskid) {
  if (taskid_ != &::google::protobuf::internal::kEmptyString) {
    delete taskid_;
  }
  if (taskid) {
    set_has_taskid();
    taskid_ = taskid;
  } else {
    clear_has_taskid();
    taskid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .dataserver.ResponseCode reponse_code = 2;
inline bool UidDeviceRes::has_reponse_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UidDeviceRes::set_has_reponse_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UidDeviceRes::clear_has_reponse_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UidDeviceRes::clear_reponse_code() {
  reponse_code_ = 0;
  clear_has_reponse_code();
}
inline ::dataserver::ResponseCode UidDeviceRes::reponse_code() const {
  return static_cast< ::dataserver::ResponseCode >(reponse_code_);
}
inline void UidDeviceRes::set_reponse_code(::dataserver::ResponseCode value) {
  assert(::dataserver::ResponseCode_IsValid(value));
  set_has_reponse_code();
  reponse_code_ = value;
}

// optional string device = 3;
inline bool UidDeviceRes::has_device() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UidDeviceRes::set_has_device() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UidDeviceRes::clear_has_device() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UidDeviceRes::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& UidDeviceRes::device() const {
  return *device_;
}
inline void UidDeviceRes::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void UidDeviceRes::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void UidDeviceRes::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UidDeviceRes::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* UidDeviceRes::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UidDeviceRes::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dataserver.UidDevices data = 4;
inline int UidDeviceRes::data_size() const {
  return data_.size();
}
inline void UidDeviceRes::clear_data() {
  data_.Clear();
}
inline const ::dataserver::UidDevices& UidDeviceRes::data(int index) const {
  return data_.Get(index);
}
inline ::dataserver::UidDevices* UidDeviceRes::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::dataserver::UidDevices* UidDeviceRes::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >&
UidDeviceRes::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::dataserver::UidDevices >*
UidDeviceRes::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dataserver

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dataserver::ResponseCode>() {
  return ::dataserver::ResponseCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dataserver::flagtype>() {
  return ::dataserver::flagtype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dataserver_2eproto__INCLUDED
